-- 
-- Table with UserIDs
-- 
-- Requirements:
-- -------------
--    - We only need a very basic version. For the FastAPI we need 
--        a SQL function `auth.validate_username_password(username, plainpw)` 
--        that returns bool.
--    - In the `evidence.???` Database we will use the unique immutable 
--        username.
-- 
-- Overview:
-- ---------
--    (A) Required Types
--    (B) Table auth.users
--    (C) Triggers for auth.users
--    (D) Other Functions for auth.users
-- 


-- -----------------------------------------------------------------------
-- (A) REQUIRED TYPES
-- -----------------------------------------------------------------------


-- 
-- auth.username_t (type check)
--    - Only lower case letters and numbers
--    - First character must be a letter
-- 
-- USAGE:
--    SELECT 'coolname123'::auth.username_t;  -- Ok
--    SELECT 'no#pe'::auth.username_t; -- Fails
--    SELECT '7nope'::auth.username_t; -- Fails
-- 
-- BEHAVIOR
--    SELECT 'Capital'::auth.username_t = 'capital'::auth.username_t; -- True
-- 

-- DROP DOMAIN IF EXISTS auth.username_t;
CREATE DOMAIN auth.username_t AS text
  CHECK ( value ~ '^[a-z][a-z0-9]+$' )
;

-- -----------------------------------------------------------------------
-- (B) TABLE auth.users
-- -----------------------------------------------------------------------

-- delete table
-- DROP TABLE IF EXISTS  auth.users;

-- setup the table again
CREATE TABLE IF NOT EXISTS
auth.users (   -- LEGACY!
  -- automatic immutable fields
    user_id        uuid DEFAULT uuid_generate_v4()
  -- immutable fields
  , username       auth.username_t NOT NULL
  -- mutable fields
  , hashed_password   bytea NOT NULL
  -- automatic mutable fields
  , isactive       boolean default TRUE
  -- documentation
  , created_at     timestamp NOT NULL default CURRENT_TIMESTAMP
  , created_by     text NOT NULL default CURRENT_USER
  , PRIMARY KEY(user_id)
);

-- keys
CREATE UNIQUE INDEX CONCURRENTLY "uk_users_1" 
  ON auth.users USING BTREE (username)
; -- for "="

-- search by
CREATE INDEX CONCURRENTLY "bt_users_2" 
  ON auth.users USING BTREE (hashed_password)
; -- for "="


-- Kommentare
COMMENT ON COLUMN auth.users.user_id IS 
  'Autogenerated UserId that is referenced in other tables. Do not expose the UserId outside the database, i.e. use auth.users.username instead.'
;
COMMENT ON COLUMN auth.users.username IS 
  'The unique immutable username for authentification purposes. It is not possible to change the username lateron. '
;

COMMENT ON COLUMN auth.users.hashed_password IS 
  'SHA-512 has of the password string. The blank password is never stored.'
;



-- -----------------------------------------------------------------------
-- (C) TRIGGERS for auth.users
--    - Prevent row DELETE
--    - Prevent UPDATE on user_id, created_at, created_by, username
-- -----------------------------------------------------------------------

-- 
-- Utility Function
-- - Raise an exception in a statement level trigger
-- - row level trigger functions are working as well
-- 
CREATE OR REPLACE FUNCTION auth.utils_raise_exception()
  RETURNS TRIGGER AS
$$
DECLARE
  errmsg text;
BEGIN
  errmsg := TG_ARGV[0];
  RAISE EXCEPTION '%s', errmsg;
END;
$$ 
LANGUAGE plpgsql
;


-- 
-- Prevent row DELETE (statement level trigger)
-- - it's not allowed to delete Users at all
-- - please change the auth.users.account_state field instead
-- 
-- DROP TRIGGER IF EXISTS trg_prevent_deletion ON auth.users;
CREATE TRIGGER trg_prevent_deletion
  BEFORE DELETE 
    ON auth.users 
  FOR EACH STATEMENT 
    EXECUTE PROCEDURE auth.utils_raise_exception(
      'DELETE on auth.users is forbidden.')
;


-- 
-- Prevent UPDATE on user_id, created_at, created_by, username
-- - these fields are immutable
-- 

-- DROP TRIGGER IF EXISTS trg_prevent_update_user_id ON auth.users;
CREATE TRIGGER trg_prevent_update_user_id
  BEFORE UPDATE 
    OF user_id ON auth.users
  FOR EACH STATEMENT 
    EXECUTE PROCEDURE auth.utils_raise_exception(
      'UPDATE of auth.users.user_id is forbidden.')
;

-- DROP TRIGGER IF EXISTS trg_prevent_update_created_at ON auth.users;
CREATE TRIGGER trg_prevent_update_created_at
  BEFORE UPDATE 
    OF created_at ON auth.users
  FOR EACH STATEMENT 
    EXECUTE PROCEDURE auth.utils_raise_exception(
      'UPDATE of auth.users.created_at is forbidden.')
;

-- DROP TRIGGER IF EXISTS trg_prevent_update_created_by ON auth.users;
CREATE TRIGGER trg_prevent_update_created_by
  BEFORE UPDATE 
    OF created_by ON auth.users
  FOR EACH STATEMENT 
    EXECUTE PROCEDURE auth.utils_raise_exception(
      'UPDATE of auth.users.created_by is forbidden.')
;

-- DROP TRIGGER IF EXISTS trg_prevent_update_username ON auth.users;
CREATE TRIGGER trg_prevent_update_username
  BEFORE UPDATE 
    OF username ON auth.users
  FOR EACH STATEMENT 
    EXECUTE PROCEDURE auth.utils_raise_exception(
      'UPDATE of auth.users.username is forbidden.')
;


-- -----------------------------------------------------------------------
-- (D) FUNCTIONS for auth.users
--    - Add new user (auth.add_user)
--    - Validate username and password (auth.validate_username_password)
--    - Check if username is active (auth.is_active_user_id)
--    - Get user_id of username (auth.username_to_userid)
-- -----------------------------------------------------------------------


-- 
-- Add a new user (returns: uuid)
-- 
-- USAGE:
--    SELECT auth.add_user('newusername', 'secretpw');
-- 
-- RETURN
--    uuid  The unique user_id
-- 
-- DROP FUNCTION IF EXISTS auth.add_user;
CREATE OR REPLACE FUNCTION auth.add_user(
    desiredname auth.username_t, plainpassword text)
  RETURNS uuid AS
$$
DECLARE
  newuser_id uuid;
BEGIN
  INSERT INTO auth.users(username, hashed_password) VALUES (
    desiredname::auth.username_t, sha512(plainpassword::bytea))
  RETURNING user_id INTO newuser_id
  ;
  RETURN newuser_id;
END;
$$ 
LANGUAGE plpgsql
;


-- 
-- Validate user account (returns: bool)
-- 
-- USAGE:
--    SELECT auth.validate_username_password('newusername', 'secretpw');
-- 
-- RETURN
--    bool  True if username/password exists
-- 
-- DROP FUNCTION IF EXISTS auth.validate_username_password;
CREATE OR REPLACE FUNCTION auth.validate_username_password(
    theusername auth.username_t, plainpassword text)
  RETURNS bool AS
$$
BEGIN
  IF (SELECT COUNT(user_id) FROM auth.users 
      WHERE username=theusername 
        AND hashed_password=sha512(plainpassword::bytea)
     ) = 1 
  THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;
$$ 
LANGUAGE plpgsql
;

-- Variant: Returns user_id
CREATE OR REPLACE FUNCTION auth.validate_username_password2(
    theusername auth.username_t, plainpassword text)
  RETURNS uuid AS
$$
BEGIN
  RETURN (SELECT user_id FROM auth.users 
           WHERE username=theusername 
             AND hashed_password=sha512(plainpassword::bytea));
END;
$$ 
LANGUAGE plpgsql
;


-- 
-- Check if user_id is active (returns: bool)
-- 
-- USAGE:
--    SELECT auth.is_active_userid('3d376550-5265-4830-9812-5e9a84cdfa29');
-- 
-- RETURN
--    bool  True if it worked, and False if it failed.
-- 
-- DROP FUNCTION IF EXISTS auth.is_active_userid;
CREATE OR REPLACE FUNCTION auth.is_active_userid(theuserid uuid)
  RETURNS bool AS
$$
BEGIN
  RETURN (SELECT isactive FROM auth.users WHERE user_id = theuserid);
END;
$$ 
LANGUAGE plpgsql
;


-- 
-- Get UserId by username (returns: uuid)
-- 
-- USAGE:
--    SELECT auth.username_to_userid('newusername');
-- 
-- RETURN
--    uuid  The unique UserId
-- 
-- DROP FUNCTION IF EXISTS auth.username_to_userid;
CREATE OR REPLACE FUNCTION auth.username_to_userid(theusername auth.username_t)
  RETURNS uuid AS
$$
BEGIN
  RETURN (SELECT user_id FROM auth.users WHERE username = theusername);
END;
$$ 
LANGUAGE plpgsql
;
