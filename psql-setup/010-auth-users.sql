-- 
-- (DRAFT!)
-- Table with UserIDs
-- 
-- Overview:
-- ---------
--    (A) Required Types
--    (B) Table auth.users
--    (C) Triggers for auth.users
--    (D) Other Functions for auth.users
-- 


-- -----------------------------------------------------------------------
-- (A) REQUIRED TYPES
-- -----------------------------------------------------------------------


-- 
-- auth.username_t (type check)
--    - Only lower case letters and numbers
--    - First character must be a letter
-- 
-- USAGE:
--    SELECT 'coolname123'::auth.username_t;  -- Ok
--    SELECT 'no#pe'::auth.username_t; -- Fails
--    SELECT '7nope'::auth.username_t; -- Fails
-- 
-- BEHAVIOR
--    SELECT 'Capital'::auth.username_t = 'capital'::auth.username_t; -- True
--  
DROP DOMAIN IF EXISTS auth.username_t
;
CREATE DOMAIN auth.username_t AS citext
  CHECK ( value ~ '^[a-z][a-z0-9]+$' )
;


-- 
-- auth.user_lifecycle_t (type check)
-- Sign Up Stages
-- 
DROP TYPE IF EXISTS auth.user_lifecycle_t
;
CREATE TYPE auth.user_lifecycle_t as ENUM(
  'created',  -- user_id created
  'deactivated',  -- Account is deactivated but all data still exists
  'reactivated', -- Account is reactivated
  'requested',  -- User request a full deletion of all data
  'deleted'  -- All data related to the user_id are deleted. The auth.users row still exist
);


-- -----------------------------------------------------------------------
-- (B) TABLE auth.users
-- -----------------------------------------------------------------------

-- delete table
-- DROP TABLE IF EXISTS  auth.users;

-- setup the table again
CREATE TABLE
IF NOT EXISTS
auth.users (
  -- automatic immutable fields
    user_id        uuid DEFAULT uuid_generate_v4()
  , created_at     timestamp NOT NULL default CURRENT_TIMESTAMP
  , created_by     text NOT NULL default CURRENT_USER
  -- immutable fields
  , username       auth.username_t NOT NULL
  -- might change over the lifetime of an user
  , account_state  auth.user_lifecycle_t DEFAULT 'created'
  , PRIMARY KEY(user_id)
  , UNIQUE(username)
);

COMMENT ON COLUMN auth.users.user_id 
  IS 'Autogenerated UserId that is referenced in other tables. Do not expose the UserId outside the database, i.e. use auth.users.username instead.'
;
COMMENT ON COLUMN auth.users.created_at
  IS ''
;
COMMENT ON COLUMN auth.users.created_by
  IS ''
;
COMMENT ON COLUMN auth.users.username
  IS 'The unique immutable username for authentification purposes. It is not possible to change the username lateron. '
;
COMMENT ON COLUMN auth.users.account_state
  IS 'Account state. a) The user "created" the account. b) The account was "deactivated", e.g. by the user, or by the sysadmin due to inactivity. c) The user "reactivated" the account what is only possible with a valid `auth.localpw.recovery_email`. d) The user "requested" the deletion of the account, e.g. it will executed after a certain waiting period. e) The account was finally "deleted" and is unrecoverable.'
;




-- -----------------------------------------------------------------------
-- (C) TRIGGERS for auth.users
--    - Prevent row DELETE
--    - Prevent UPDATE on user_id, created_at, created_by, username
-- -----------------------------------------------------------------------

-- 
-- Utility Function
-- - Raise an exception in a statement level trigger
-- - row level trigger functions are working as well
-- 
CREATE OR REPLACE FUNCTION auth.utils_raise_exception()
  RETURNS TRIGGER AS
$$
DECLARE
  errmsg text;
BEGIN
  errmsg := TG_ARGV[0];
  RAISE EXCEPTION '%s', errmsg;
END;
$$ 
LANGUAGE plpgsql
;


-- 
-- Prevent row DELETE (statement level trigger)
-- - it's not allowed to delete Users at all
-- - please change the auth.users.account_state field instead
-- 
DROP TRIGGER IF EXISTS trg_prevent_deletion ON auth.users
;
CREATE TRIGGER trg_prevent_deletion
  BEFORE DELETE 
    ON auth.users 
  FOR EACH STATEMENT 
    EXECUTE PROCEDURE auth.utils_raise_exception(
      'DELETE on auth.users is forbidden.')
;


-- 
-- Prevent UPDATE on user_id, created_at, created_by, username
-- - these fields are immutable
-- 
DROP TRIGGER IF EXISTS trg_prevent_update_user_id ON auth.users
;
CREATE TRIGGER trg_prevent_update_user_id
  BEFORE UPDATE 
    OF user_id ON auth.users
  FOR EACH STATEMENT 
    EXECUTE PROCEDURE auth.utils_raise_exception(
      'UPDATE of auth.users.user_id is forbidden.')
;

DROP TRIGGER IF EXISTS trg_prevent_update_created_at ON auth.users
;
CREATE TRIGGER trg_prevent_update_created_at
  BEFORE UPDATE 
    OF created_at ON auth.users
  FOR EACH STATEMENT 
    EXECUTE PROCEDURE auth.utils_raise_exception(
      'UPDATE of auth.users.created_at is forbidden.')
;

DROP TRIGGER IF EXISTS trg_prevent_update_created_by ON auth.users
;
CREATE TRIGGER trg_prevent_update_created_by
  BEFORE UPDATE 
    OF created_by ON auth.users
  FOR EACH STATEMENT 
    EXECUTE PROCEDURE auth.utils_raise_exception(
      'UPDATE of auth.users.created_by is forbidden.')
;

DROP TRIGGER IF EXISTS trg_prevent_update_username ON auth.users
;
CREATE TRIGGER trg_prevent_update_username
  BEFORE UPDATE 
    OF username ON auth.users
  FOR EACH STATEMENT 
    EXECUTE PROCEDURE auth.utils_raise_exception(
      'UPDATE of auth.users.username is forbidden.')
;


-- -----------------------------------------------------------------------
-- (D) FUNCTIONS for auth.users
--    - Check if desired username is valid (auth.is_valid_username)
--    - Add new user (auth.add_new_user)
--    - Change account state ()
-- -----------------------------------------------------------------------


-- 
-- Check if a username is availabe (returns: bool)
-- 
-- USAGE:
--    SELECT auth.is_available_username('newusername');
-- 
-- RETURN
--    bool  True if the desired username is valid, and False if not.
-- 
DROP FUNCTION IF EXISTS auth.is_available_username
;
CREATE OR REPLACE FUNCTION auth.is_available_username(desiredname text)
  RETURNS bool AS
$$
BEGIN
  -- username is not written correctly
  IF NOT (desiredname ~ '^[a-z][a-z0-9]+$') THEN
    RETURN FALSE;
  END IF;
  -- username already exists
  IF (SELECT COUNT(user_id) FROM auth.users WHERE username=desiredname) > 0 THEN
    RETURN FALSE;
  END IF;
  -- everything ok
  RETURN TRUE;
END;
$$ 
LANGUAGE plpgsql
;


-- 
-- Add a new user (returns: bool)
-- 
-- USAGE:
--    SELECT auth.add_new_user('newusername');
-- 
-- RETURN
--    bool  True if it worked, and False if it failed.
-- 
DROP FUNCTION IF EXISTS auth.add_new_user
;
CREATE OR REPLACE FUNCTION auth.add_new_user(desiredname text)
  RETURNS bool AS
$$
BEGIN
  -- check if desired username is valid
  IF auth.is_available_username(desiredname) THEN
    INSERT INTO auth.users(username) VALUES (desiredname::auth.username_t);
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;
$$ 
LANGUAGE plpgsql
;


-- 
-- Get UserId by username (returns: uuid)
-- 
-- USAGE:
--    SELECT auth.username_to_userid('newusername');
-- 
-- RETURN
--    uuid  The unique UserId
-- 
DROP FUNCTION IF EXISTS auth.username_to_userid
;
CREATE OR REPLACE FUNCTION auth.username_to_userid(myname text)
  RETURNS uuid AS
$$
BEGIN
  RETURN (SELECT user_id FROM auth.users WHERE username = myname);
END;
$$ 
LANGUAGE plpgsql
;


-- 
-- Check if username is active (returns: bool)
-- 
-- USAGE:
--    SELECT auth.is_active_username('newusername');
-- 
-- RETURN
--    bool  True if it worked, and False if it failed.
-- 
DROP FUNCTION IF EXISTS auth.is_active_username
;
CREATE OR REPLACE FUNCTION auth.is_active_username(myname text)
  RETURNS bool AS
$$
BEGIN
  RETURN (SELECT account_state IN ('created', 'reactivated')
          FROM auth.users WHERE username = myname);
END;
$$ 
LANGUAGE plpgsql
;


-- deactivate account, reactivate account, request deletion
-- Returns True if successful
DROP FUNCTION IF EXISTS auth.deactivate_account
;
CREATE OR REPLACE FUNCTION auth.deactivate_account(theusername text)
  RETURNS bool AS
$$
BEGIN
  UPDATE auth.users
  SET account_state = 'deactivated'
  WHERE username = theusername
  ;
  RETURN FOUND;
END;
$$ 
LANGUAGE plpgsql
;

DROP FUNCTION IF EXISTS auth.reactivate_account
;
CREATE OR REPLACE FUNCTION auth.reactivate_account(theusername text)
  RETURNS bool AS
$$
BEGIN
  UPDATE auth.users
  SET account_state = 'reactivated'
  WHERE username = theusername
  ;
  RETURN FOUND;
END;
$$ 
LANGUAGE plpgsql
;

DROP FUNCTION IF EXISTS auth.request_deletion
;
CREATE OR REPLACE FUNCTION auth.request_deletion(theusername text)
  RETURNS bool AS
$$
BEGIN
  UPDATE auth.users
  SET account_state = 'requested'
  WHERE username = theusername
  ;
  RETURN FOUND;
END;
$$ 
LANGUAGE plpgsql
;

